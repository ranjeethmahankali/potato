"""This script is a debugging tool.

This will help fix bugs in move generation by comparing the move
generation of potato with that of stockfish.
"""

import subprocess


def makeNewFen(oldfen: str, move: str):
    """Get the new fen after applying moves to the old fen."""
    fish = subprocess.Popen('stockfish',
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    out, err = fish.communicate(input=bytes(
        f"position fen \"{oldfen}\" moves {move}\nd\nquit\n", "ascii"))
    fish.kill()
    fenline = [
        ln for ln in out.decode().splitlines() if ln.startswith("Fen: ")
    ][0]
    return fenline.removeprefix('Fen: ')


class PositionTree:
    """Useful for comparing move generation."""

    def __init__(self, fen=None, depth=4, ht=0):
        """Create a new search tree."""
        self.fen = fen
        self.depth = depth
        self.ht = ht

    def indent(self):
        """Get indentation for printing messages based on the search depth."""
        return '    ' * self.ht

    def perftFish(self):
        """Do perft with stockfish and get sorted results."""
        fish = subprocess.Popen('stockfish',
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        out, err = fish.communicate(input=bytes(
            f"position fen \"{self.fen}\"\ngo perft {self.depth}\nquit\n",
            "ascii"))
        fish.kill()
        lines = sorted([
            ln.lower() for ln in out.decode().splitlines()[1:] if ln
            and ': ' in ln and not ln.lower().startswith("nodes searched")
        ])
        pairs = [ln.split(": ") for ln in lines]
        return {p[0]: int(p[1]) for p in pairs}

    def perftPotato(self):
        """Do perft with potato and get sorted results."""
        potato = subprocess.Popen(['Release/potato', '--cli'],
                                  stdin=subprocess.PIPE,
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
        out, err = potato.communicate(input=bytes(
            f"fen \"{self.fen}\"\nperft {self.depth}\nquit\n", "ascii"))
        potato.kill()
        lines = sorted([
            ln.lower() for ln in out.decode().splitlines() if ln and ': ' in ln
            and not ln.startswith('[') and not ln.startswith('Total')
        ])
        pairs = [ln.split(": ") for ln in lines]
        if (len(pairs) != len(set([p[0] for p in pairs]))):
            print(f"{self.indent()}!!! Repeated move.")
        return {p[0]: int(p[1]) for p in pairs}

    def compare(self):
        """Compare the results of stockfish and potato."""
        print(f"{self.indent()}Comparing fen: {self.fen}")
        fdata = self.perftFish()
        pdata = self.perftPotato()
        problems = []
        success = True
        for move in fdata:
            if move not in pdata:
                success = False
                print(f"{self.indent()}Move {move} not generated by potato.")
        for move in pdata:
            if move not in fdata:
                success = False
                print(f"{self.indent()}Move {move} is illegal.")
        for move in fdata:
            if move in pdata and fdata[move] != pdata[move]:
                success = False
                print(f"{self.indent()}The perft move count for {move} "
                      f"is incorrect ({fdata[move]} != {pdata[move]})")
                problems.append(move)
        if self.depth == 1:
            return success
        # Recursive compare for all the problems
        for problem in problems:
            print(f"{self.indent()}Recursing the search with move {problem}")
            newfen = makeNewFen(self.fen, problem)
            if newfen == self.fen:
                continue
            r = PositionTree(newfen, self.depth - 1, self.ht + 1)
            childSuccess = r.compare()
            if childSuccess:
                print(f"{self.indent()}Inconsistent position:")
                print(f"{self.indent()}Before: {self.fen}")
                print(f"{self.indent()}After: {newfen}")
                print(f"{self.indent()}Move: {problem}")
                success = False
        return success


if __name__ == "__main__":
    r = PositionTree("2r5/8/p6p/1p2R3/8/2P2k2/PP3P1P/3R2K1 b - - 2 31", 6)
    if r.compare():
        print("All checks passed!")
