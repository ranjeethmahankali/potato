"""This script is a debugging tool.

This will help fix bugs in move generation by comparing the move
generation of potato with that of stockfish.
"""

import subprocess


def makeNewFen(oldfen: str, move: str):
    """Get the new fen after applying moves to the old fen."""
    fish = subprocess.Popen('stockfish',
                            stdin=subprocess.PIPE,
                            stdout=subprocess.PIPE,
                            stderr=subprocess.PIPE)
    out, err = fish.communicate(input=bytes(
        f"position fen \"{oldfen}\" moves {move}\nd\nquit\n", "ascii"))
    fish.kill()
    fenline = [
        ln for ln in out.decode().splitlines() if ln.startswith("Fen: ")
    ][0]
    return fenline.removeprefix('Fen: ')


class PositionTree:
    """Useful for comparing move generation."""

    def __init__(self, fen=None, depth=4, ht=0):
        """Create a new search tree."""
        self.fen = fen
        self.depth = depth
        self.ht = ht

    def indent(self):
        """Get indentation for printing messages based on the search depth."""
        return '    ' * self.ht

    def perftFish(self):
        """Do perft with stockfish and get sorted results."""
        fish = subprocess.Popen('stockfish',
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        out, err = fish.communicate(input=bytes(
            f"position fen \"{self.fen}\"\ngo perft {self.depth}\nquit\n",
            "ascii"))
        fish.kill()
        lines = sorted([
            ln.lower() for ln in out.decode().splitlines()[1:] if ln
            and ': ' in ln and not ln.lower().startswith("nodes searched")
        ])
        pairs = [ln.split(": ") for ln in lines]
        return {p[0]: int(p[1]) for p in pairs}

    def perftPotato(self):
        """Do perft with potato and get sorted results."""
        potato = subprocess.Popen(['Release/potato', '--cli'],
                                  stdin=subprocess.PIPE,
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
        out, err = potato.communicate(input=bytes(
            f"fen \"{self.fen}\"\nperft {self.depth}\nquit\n", "ascii"))
        potato.kill()
        lines = sorted([
            ln.lower() for ln in out.decode().splitlines() if ln and ': ' in ln
            and not ln.startswith('[') and not ln.startswith('Total')
        ])
        pairs = [ln.split(": ") for ln in lines]
        return {p[0]: int(p[1]) for p in pairs}

    def compare(self):
        """Compare the results of stockfish and potato."""
        fdata = self.perftFish()
        pdata = self.perftPotato()
        problems = []
        print(f"{self.indent()}Comparing fen: {self.fen}")
        for move in fdata:
            if move not in pdata:
                print(f"{self.indent()}Move {move} not generated by potato.")
        for move in pdata:
            if move not in fdata:
                print(f"{self.indent()}Move {move} is illegal.")
        for move in fdata:
            if move in pdata and fdata[move] != pdata[move]:
                print(f"{self.indent()}The perft move count for {move} "
                      "is incorrect.")
                problems.append(move)
        if self.depth == 1:
            return
        # Recursive compare for all the problems
        for problem in problems:
            print(f"{self.indent()}Recursing the search with move {problem}")
            newfen = makeNewFen(self.fen, problem)
            if newfen == self.fen:
                continue
            r = PositionTree(newfen, self.depth - 1, self.ht + 1)
            r.compare()


r = PositionTree("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", 5)
r.compare()
